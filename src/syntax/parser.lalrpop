use std::sync::RwLockWriteGuard;
use std::str::FromStr;

use codespan::{Span, RawIndex};

use crate::syntax::{Expr, EnumExpr, FuncExpr, CallExpr, LetExpr, RecExpr, IfExpr, ProjExpr,
    MatchExpr, MatchExprCase, Spanned
};
use crate::syntax::symbol::{Symbol, Interner};

grammar(interner: &mut RwLockWriteGuard<'_, Interner>);

pub(crate) SpannedExpr = Spanned<Expr>;

Expr: Expr = {
    FuncExpr => Expr::Func(Box::new(<>)),
    CallExpr => Expr::Call(Box::new(<>)),
    LetExpr => Expr::Let(Box::new(<>)),
    RecExpr => Expr::Rec(Box::new(<>)),
    IfExpr => Expr::If(Box::new(<>)),
    MatchExpr => Expr::Match(Box::new(<>)),
    ImportExpr,
    SimpleExpr,
}

FuncExpr: FuncExpr = {
    "func" <arg:Spanned<Symbol>> "=>" <body:Spanned<Expr>> => FuncExpr { <> },
}

CallExpr: CallExpr = {
    <func:Spanned<CallFuncExpr>> <arg:Spanned<SimpleExpr>> => CallExpr { <> },
}

CallFuncExpr: Expr = {
    SimpleExpr,
    CallExpr => Expr::Call(Box::new(<>)),
}

LetExpr: LetExpr = {
    "let" <name:Spanned<Symbol>> "=" <val:Spanned<Expr>> "in" <body:Spanned<Expr>> => LetExpr { <> },
}

RecExpr: RecExpr = {
    "let" "rec" <name:Spanned<Symbol>> "=" <func:Spanned<FuncExpr>> "in" <body:Spanned<Expr>> => RecExpr { <> },
}

IfExpr: IfExpr = {
    "if" <cond:Spanned<Expr>> "then" <cons:Spanned<Expr>> "else" <alt:Spanned<Expr>> => IfExpr { <> },
}

ProjExpr: ProjExpr = {
    <expr:Spanned<SimpleExpr>> "." <field:Spanned<Symbol>> => ProjExpr { <> },
}

MatchExpr: MatchExpr = {
    "match" <expr:Spanned<Expr>> "with" "[" <cases:Comma<Spanned<MatchCase>>> "]" => MatchExpr {
        expr, cases: cases.into_iter().map(|spanned| (spanned.val.0, Spanned {
            val: spanned.val.1,
            span: spanned.span,
        })).collect(),
    }
}

EnumExpr: EnumExpr = {
    "[" <tag:Spanned<Symbol>> <expr:(":" <Spanned<Expr>>)?> "]" => EnumExpr { <> },
}

MatchCase: (Symbol, MatchExprCase) = {
    <tag:Symbol> "=>" <expr:Spanned<Expr>> => (tag, MatchExprCase {
        name: None, expr,
    }),
    <tag:Symbol> ":" <name:Spanned<Symbol>> "=>" <expr:Spanned<Expr>> => (tag, MatchExprCase {
        name: Some(name), expr,
    }),
}

ImportExpr: Expr = {
    "import" <path:String> => Expr::Import(path),
}

SimpleExpr: Expr = {
    "null" => Expr::Null,
    "true" => Expr::Bool(true),
    "false" => Expr::Bool(false),
    Symbol => Expr::Var(<>),
    Int => Expr::Int(<>),
    String => Expr::String(<>),
    "{" <fields:Comma<Entry>> "}" => Expr::Record(fields.into_iter().collect()),
    EnumExpr => Expr::Enum(Box::new(<>)),
    ProjExpr => Expr::Proj(Box::new(<>)),
    "(" <Expr> ")",
}

Entry: (Symbol, Spanned<Expr>) = {
    <s:Symbol> ":" <e:Spanned<Expr>> => (s, e),
    <s:Spanned<Symbol>> => (s.val, Spanned {
        val: Expr::Var(s.val),
        span: s.span,
    }),
}

Spanned<T>: Spanned<T> = {
    <l:@L> <val:T> <r:@R> => Spanned {
        val, span: Span::new(l as RawIndex, r as RawIndex)
    }
}

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

Symbol: Symbol = {
    r"[[:alpha:]_]+" => interner.intern(<>),
}

Int: i64 = {
    r"-?\d+" => i64::from_str(<>).unwrap(),
}

String: String = {
    <s:r##""(?:[^\\"]|(?:\\")|(?:\\\\))*""##> => {
        s[1..(s.len() - 1)]
            .replace("\\\"", "\"")
            .replace("\\\\", "\\")
    },
}
