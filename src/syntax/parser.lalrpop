use std::rc::Rc;
use std::sync::RwLockWriteGuard;
use std::str::FromStr;

use crate::syntax::Expr;
use crate::syntax::symbol::{Symbol, Interner};

grammar(interner: &mut RwLockWriteGuard<'_, Interner>);

pub(crate) Expr: Expr = {
    AbsExpr,
    AppExpr,
    LetExpr,
    IfExpr,
    SimpleExpr,
}

AbsExpr: Expr = {
    "func" <s:Symbol> "=>" <e:Expr> => Expr::Abs(s, Rc::new(e)),
}

AppExpr: Expr = {
    <f:AppFuncExpr> <v:SimpleExpr> => Expr::App(Rc::new(f), Rc::new(v)),
}

AppFuncExpr = { SimpleExpr, AppExpr }

LetExpr: Expr = {
    "let" <s:Symbol> "=" <v:Expr> "in" <e:Expr> => Expr::Let(s, Rc::new(v), Rc::new(e)),
    "let" "rec" <s:Symbol> "=" <v:AbsExpr> "in" <e:Expr> => Expr::Rec(s, Rc::new(v), Rc::new(e)),
}

IfExpr: Expr = {
    "if" <c:Expr> "then" <t:Expr> "else" <f:Expr> => Expr::If(Rc::new(c), Rc::new(t), Rc::new(f)),
}

SimpleExpr: Expr = {
    "true" => Expr::Bool(true),
    "false" => Expr::Bool(false),
    Symbol => Expr::Var(<>),
    Int => Expr::Int(<>),
    "{" <fields:Comma<(<Symbol> ":" <Expr>)>> "}" => Expr::Cons(fields.into_iter().collect()),
    <e:SimpleExpr> "." <s:Symbol> => Expr::Proj(Rc::new(e), s),
    "(" <Expr> ")",
}

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

Symbol: Symbol = {
    r"[[:alpha:]]+" => interner.intern(<>),
}

Int: i64 = {
    r"-?\d+" => i64::from_str(<>).unwrap(),
}
