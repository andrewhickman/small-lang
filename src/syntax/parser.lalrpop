use std::sync::RwLockWriteGuard;
use std::str::FromStr;

use codespan::{Span, RawIndex};

use crate::syntax::{Expr, EnumExpr, FuncExpr, CallExpr, LetExpr, RecExpr, IfExpr, ProjExpr, Spanned};
use crate::syntax::symbol::{Symbol, Interner};

grammar(interner: &mut RwLockWriteGuard<'_, Interner>);

pub(crate) SpannedExpr = Spanned<Expr>;

Expr: Expr = {
    FuncExpr => Expr::Func(Box::new(<>)),
    CallExpr => Expr::Call(Box::new(<>)),
    LetExpr => Expr::Let(Box::new(<>)),
    RecExpr => Expr::Rec(Box::new(<>)),
    IfExpr => Expr::If(Box::new(<>)),
    ImportExpr,
    SimpleExpr,
}

FuncExpr: FuncExpr = {
    "func" <arg:Spanned<Symbol>> "=>" <body:Spanned<Expr>> => FuncExpr { <> },
}

CallExpr: CallExpr = {
    <func:Spanned<CallFuncExpr>> <arg:Spanned<SimpleExpr>> => CallExpr { <> },
}

CallFuncExpr: Expr = {
    SimpleExpr,
    CallExpr => Expr::Call(Box::new(<>)),
}

LetExpr: LetExpr = {
    "let" <name:Spanned<Symbol>> "=" <val:Spanned<Expr>> "in" <body:Spanned<Expr>> => LetExpr { <> },
}

RecExpr: RecExpr = {
    "let" "rec" <name:Spanned<Symbol>> "=" <func:Spanned<FuncExpr>> "in" <body:Spanned<Expr>> => RecExpr { <> },
}

IfExpr: IfExpr = {
    "if" <cond:Spanned<Expr>> "then" <cons:Spanned<Expr>> "else" <alt:Spanned<Expr>> => IfExpr { <> },
}

ProjExpr: ProjExpr = {
    <expr:Spanned<SimpleExpr>> "." <field:Spanned<Symbol>> => ProjExpr { <> },
}

ImportExpr: Expr = {
    "import" <path:String> => Expr::Import(path),
}

SimpleExpr: Expr = {
    "true" => Expr::Bool(true),
    "false" => Expr::Bool(false),
    Symbol => Expr::Var(<>),
    Int => Expr::Int(<>),
    String => Expr::String(<>),
    "{" <fields:Comma<Entry>> "}" => Expr::Record(fields.into_iter().collect()),
    "[" <entry:Entry> "]" => Expr::Enum(Box::new(EnumExpr {
        tag: entry.0,
        expr: entry.1,
    })),
    ProjExpr => Expr::Proj(Box::new(<>)),
    "(" <Expr> ")",
}

Entry: (Symbol, Spanned<Expr>) = {
    <s:Symbol> ":" <e:Spanned<Expr>> => (s, e),
    <s:Spanned<Symbol>> => (s.val, Spanned {
        val: Expr::Var(s.val),
        span: s.span,
    }),
}

Spanned<T>: Spanned<T> = {
    <l:@L> <val:T> <r:@R> => Spanned {
        val, span: Span::new(l as RawIndex, r as RawIndex)
    }
}

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

Symbol: Symbol = {
    r"[[:alpha:]_]+" => interner.intern(<>),
}

Int: i64 = {
    r"-?\d+" => i64::from_str(<>).unwrap(),
}

String: String = {
    <s:r##""(?:[^\\"]|(?:\\")|(?:\\\\))*""##> => {
        s[1..(s.len() - 1)]
            .replace("\\\"", "\"")
            .replace("\\\\", "\\")
    },
}
