use std::str::FromStr;
use std::sync::RwLockWriteGuard;

use codespan::{RawIndex, Span};
use itertools::rev;
use lalrpop_util::ParseError;

use crate::syntax::symbol::{Interner, Symbol};
use crate::syntax::{
    CallExpr, EnumExpr, Expr, FuncExpr, IfExpr, LetExpr, MatchExpr, MatchExprCase, ProjExpr,
    RecExpr, Spanned, Error,
};

grammar(interner: &mut RwLockWriteGuard<'_, Interner>);

extern {
    type Error = Error;
}

pub(crate) SpannedExpr = Spanned<Expr>;

Expr: Expr = {
    FuncExpr => Expr::Func(Box::new(<>)),
    CallExpr => Expr::Call(Box::new(<>)),
    LetExpr => Expr::Let(Box::new(<>)),
    RecExpr => Expr::Rec(Box::new(<>)),
    IfExpr => Expr::If(Box::new(<>)),
    SimpleExpr,
}

FuncExpr: FuncExpr = {
    "func" <args:Spanned<Symbol>*> <arg:Spanned<Symbol>> "=>" <body:Spanned<Expr>> => {
        let mut func = FuncExpr { arg, body };
        for arg in rev(args) {
            let span = Span::new(arg.span.start(), func.body.span.end());
            func = FuncExpr { arg, body:
                Spanned {
                    span, val: Expr::Func(Box::new(func))
                }
            };
        }
        func
    }
}

CallExpr: CallExpr = {
    <func:Spanned<CallFuncExpr>> <arg:Spanned<SimpleExpr>> => CallExpr { <> },
}

CallFuncExpr: Expr = {
    SimpleExpr,
    CallExpr => Expr::Call(Box::new(<>)),
}

LetExpr: LetExpr = {
    "let" <name:Spanned<Symbol>> "=" <val:Spanned<Expr>> "in" <body:Spanned<Expr>> => LetExpr { <> },
}

RecExpr: RecExpr = {
    "let" "rec" <name:Spanned<Symbol>> "=" <func:Spanned<FuncExpr>> "in" <body:Spanned<Expr>> => RecExpr { <> },
}

IfExpr: IfExpr = {
    "if" <cond:Spanned<Expr>> "then" <cons:Spanned<Expr>> "else" <alt:Spanned<Expr>> => IfExpr { <> },
}

ProjExpr: ProjExpr = {
    <expr:Spanned<SimpleExpr>> "." <field:Spanned<Symbol>> => ProjExpr { <> },
}

MatchExpr: MatchExpr = {
    "match" <expr:Spanned<Expr>> "with" "[" <cases:Comma<Spanned<MatchCase>>> "]" => MatchExpr {
        expr, cases: cases.into_iter().map(|spanned| (spanned.val.0, Spanned {
            val: spanned.val.1,
            span: spanned.span,
        })).collect(),
    }
}

EnumExpr: EnumExpr = {
    "[" <tag:Spanned<Symbol>> <expr:(":" <Spanned<Expr>>)?> "]" => EnumExpr { <> },
}

MatchCase: (Symbol, MatchExprCase) = {
    <tag:Symbol> "=>" <expr:Spanned<Expr>> => (tag, MatchExprCase {
        name: None, expr,
    }),
    <tag:Symbol> ":" <name:Spanned<Symbol>> "=>" <expr:Spanned<Expr>> => (tag, MatchExprCase {
        name: Some(name), expr,
    }),
}

ImportExpr: Expr = {
    "import" <path:String> => Expr::Import(path),
}

SimpleExpr: Expr = {
    "null" => Expr::Null,
    "(" ")" => Expr::Null,
    "true" => Expr::Bool(true),
    "false" => Expr::Bool(false),
    Symbol => Expr::Var(<>),
    Int => Expr::Int(<>),
    Float => Expr::Float(<>),
    String => Expr::String(<>),
    "{" <fields:Comma<Entry>> "}" => Expr::Record(fields.into_iter().collect()),
    EnumExpr => Expr::Enum(Box::new(<>)),
    ProjExpr => Expr::Proj(Box::new(<>)),
    MatchExpr => Expr::Match(Box::new(<>)),
    ImportExpr,
    "(" <Expr> ")",
}

Entry: (Symbol, Spanned<Expr>) = {
    <s:Symbol> ":" <e:Spanned<Expr>> => (s, e),
    <s:Spanned<Symbol>> => (s.val, Spanned {
        val: Expr::Var(s.val),
        span: s.span,
    }),
}

Spanned<T>: Spanned<T> = {
    <l:@L> <val:T> <r:@R> => Spanned {
        val, span: Span::new(l as RawIndex, r as RawIndex)
    }
}

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

Symbol: Symbol = {
    identifier => interner.intern(<>),
}

Int: i64 = {
    <l:@L> <i:integer> <r:@R> =>? match i64::from_str(i) {
        Ok(val) => Ok(val),
        Err(err) => Err(ParseError::User {
            error: Error::new(l as RawIndex, r as RawIndex, format!("error parsing integer: {}", err)),
        }),
    }
}

Float: f64 = {
    <l:@L> <f:float> <r:@R> =>? match f64::from_str(f) {
        Ok(val) => Ok(val),
        Err(err) => Err(ParseError::User {
            error: Error::new(l as RawIndex, r as RawIndex, format!("error parsing float: {}", err)),
        }),
    }
}

String: String = {
    <s:string> => {
        s[1..(s.len() - 1)]
            .replace("\\\"", "\"")
            .replace("\\\\", "\\")
    },
}

match {
    "func", "let", "rec", "in", "if", "then", "else", "match", "with", "import", "null", "false", "true",
    "=", ".", "(", ")", "[", "]", "{", "}", "=>", ":", ",",
} else {
    r"-?\d+" => integer,
} else {
    r"-?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?" => float,
} else {
    r"[[:alnum:]_]*" => identifier,
    r##""(?:[^\\"]|(?:\\")|(?:\\\\))*""## => string,
}
