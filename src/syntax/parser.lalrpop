use std::sync::RwLockWriteGuard;
use std::str::FromStr;

use crate::syntax::Expr;
use crate::syntax::symbol::{Symbol, Interner};

grammar(interner: &mut RwLockWriteGuard<'_, Interner>);

pub(crate) Expr: Expr = {
    FuncExpr,
    AppExpr,
    LetExpr,
    IfExpr,
    ImportExpr,
    SimpleExpr,
}

FuncExpr: Expr = {
    "func" <s:Symbol> "=>" <e:Expr> => Expr::Func(s, Box::new(e)),
}

AppExpr: Expr = {
    <f:AppFuncExpr> <v:SimpleExpr> => Expr::Call(Box::new(f), Box::new(v)),
}

AppFuncExpr = { SimpleExpr, AppExpr }

LetExpr: Expr = {
    "let" <s:Symbol> "=" <v:Expr> "in" <e:Expr> => Expr::Let(s, Box::new(v), Box::new(e)),
    "let" "rec" <s:Symbol> "=" <v:FuncExpr> "in" <e:Expr> => Expr::Rec(s, Box::new(v), Box::new(e)),
}

IfExpr: Expr = {
    "if" <c:Expr> "then" <t:Expr> "else" <f:Expr> => Expr::If(Box::new(c), Box::new(t), Box::new(f)),
}

ImportExpr: Expr = {
    "import" <path:String> => Expr::Import(path),
}

SimpleExpr: Expr = {
    "true" => Expr::Bool(true),
    "false" => Expr::Bool(false),
    Symbol => Expr::Var(<>),
    Int => Expr::Int(<>),
    String => Expr::String(<>),
    "{" <fields:Comma<RecordEntry>> "}" => Expr::Record(fields.into_iter().collect()),
    <e:SimpleExpr> "." <s:Symbol> => Expr::Proj(Box::new(e), s),
    "(" <Expr> ")",
}

RecordEntry: (Symbol, Expr) = {
    <s:Symbol> ":" <e:Expr> => (s, e),
    <s:Symbol> => (s, Expr::Var(s)),
}

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

Symbol: Symbol = {
    r"[[:alpha:]_]+" => interner.intern(<>),
}

Int: i64 = {
    r"-?\d+" => i64::from_str(<>).unwrap(),
}

String: String = {
    <s:r##""(?:[^\\"]|(?:\\")|(?:\\\\))*""##> => {
        s[1..(s.len() - 1)]
            .replace("\\\"", "\"")
            .replace("\\\\", "\\")
    },
}
